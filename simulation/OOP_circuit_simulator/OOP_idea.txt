# parent class logic gates.
# child class INV gatas. NAND2, NOR2 etc. they are all classes.
# each specific gates is then an instance.

# other classes, nets, capacitances, resistors.


#

'''
a logic gate class should have an variable

input nets,
output nets,

optional, status, active or non-active, according to event driven simulation



net class should have variable

voltage

'''

# idea.

at the very start. standard netlist will be read. e.g. verilog netlist

net will first be created.

then, create logic gates.

logic gates are th main actors, nets are places to store voltage values.






##################################################################

if I were to forget OOP,

and just would like to do circuit simulation in correct way,
how would I retrive cap value from next gate.



at the initial set up, input cap value of next stage should be remembered by nets.
then at very first time step, fist level 1 gate goto active simulate.

they have input dV, they simulate and get output dV.

then it's second level gate's turn. in the mean time, first level gate can move on to next time step, if were to do this
on GPU.

but for now, I will just freeze the time step, go gate by gate, down the level, then move on to next time step.

by doing this, we move down the whole circuit. no problem.
when doing the first gate, it's cap load is the input cap of second stage, which is written by second stage during intial
setup


net should have a function to record it's voltage across the simulation time.


# big discorvery, when an object is passed in a function as input, if you change an attribute of this object within this
function, it will be refelected outside this function on the actual object.

instead of like regualr variable, if you put it as input to a fucntino, and change it inside this function, the change
is only reflected within this function.

one signle attribut of an object is regarded as a regular variable. only when an object is passed to a fuction as a whole,

this "global" variable like behavior exists. My obervation till now

now the debate is whether to put simulate function of a gate inside or outside the class.

net will for sure be an instance, to exploit this property.



consider let simulate function return output net voltage. but that's not very OOP style, OOP pass in object as arguments.

That can act as both intput can output reviever. to my understanding now, this is OOP style.

dict contains object as input argument is fine, it still has this property.
seems as long as scope is larger than object is fine.

I want to pass all nets as a dict of instances. so that the simulate function intput argument is the same for all gates.

instead of feeding 2 object as input to NAND, 1 input object to INV.


input output net at logic gate init method can be instance as well, and can be changed globally

also put LUT and boundry in init method, because we don't want to make specific "simulate" statement for each gate during
simulation.

we can however, make specific statement when we are creating the gatas, since that's when we read the netlist anyway.


net voltage storage for simulation. simulation need dV, hence, we need to know the history of voltages.
This problem can be combined with voltage storing.
do we store the complete list of voltage change, and carry it around, or just store voltage now, and voltage just now

also, use old Vin for LUT reading.


# design choice, to revel NAND2 internal node as a net to top level circuit or not.

choice, hide internal node, since verilog netlist format nand2 has no internal node connection.

as for the internal node initail voltage, set at 0 by default.

# challenge, how to update logic gate input capacitance value to corresponding net.

we know that when a gate is simulated, it is good change to updata its input cap value to the net instance.

since circuit is simulated from left to right, input to output. next time when left gate is simulated, it's going to see
right gate input cap value of last time, which is correct.

## in this coding, I choose to treat gate as primary actor, net as passive data storage. since when creating netlist,
gate is main character, and net is attached to gate.

hence, net has no idea who it is connected to. This limits the possibility to let net invoke it's follower gate to read
their input cap on the fly.

can have a dict in net instance, under the cap_load attribute.

let gate put their corresponding cap value in it, when gate updating, it just update its own field, when net need cap load value,
it just sum it all up.

this compare to the read on the fly approach, reduce LUT reading. becuase when simulating a gate, LUT read up is avaliable anyway.
this approach need to consider inital simulation start up. can create a separate function to read it during start up.
can set an argument "idle" to simualte function. if idle (during inital startup). simulate function would not commit

commit change to any voltage node, it would just update cap value

the net cap dict key entry can be a gate's name.

currently, a net or gate do not have their name stored as attributs. seems to be a bad idea, since object may not have
unique names. I will just add a "name" field to all gates and nets. and pass it into the object upon creation.

I decide to use verilog netlist, since it identifies the input output and internal nets clearly.
also verilog netlist create nets first, gates later. this matches with my gate oriented OOP

# testing codes
# see if it works
#print nets_dict.keys()
#print gates_dict.keys()

#print gates_dict["NAND2_3"].output_net.name
#print gates_dict["NAND2_3"].input_net_A.name

#CL = nets_dict["N22"].sum_CL()
#print CL

#for each_level in range(len(level_list)):
#    print "level: " + str(each_level) + " elements:" + str(level_list[each_level])
# very good, it works


#CL = nets_dict["N6"].sum_CL()
#print CL

# unused code
# very much like the sim function of gates, this function push the Primary Inputs (PI) forward in time
def update_PI_voltage(PI_instance, signal, time_now):
    PI_instance.update_voltage(signal(time_now))

'''
for t_step in range(t_tot):
    for each_gate in all_gate_list:
        #do simulation

        each_gate.simulate(all_nets)
'''



# use a config file reader, that can read any config file, the proper way.
#take config_dir as input to main
#TODO: use a file IO and read which ever config file is the way to go
config_file = open(config_dir, "r")

verilog_netlist_dir = None



for line in config_file:
    if (line[0] != "#"):
        if "verilog_netlist_dir" in line:
            verilog_netlist_dir = line.split()[-1] # title, "=", value
        elif "NAND2_LUT_dir" in line:
            NAND2_LUT_dir = line.split()[-1] # title, "=", value
        elif "verilog_netlist_dir" in line:
            verilog_netlist_dir = line.split()[-1] # title, "=", value
        elif "verilog_netlist_dir" in line:
            verilog_netlist_dir = line.split()[-1] # title, "=", value








def create_net_instance(list_of_net): # create_net_instance from list of net names to be created
    for each_item in list_of_net:
        net_name = each_item
        nets_dict[net_name] = net(name=net_name, initial_voltage=0)